

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dta.Network &mdash; DTA Anyway v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="DTA Anyway v1.0 documentation" href="../index.html" />
    <link rel="next" title="dta.Path" href="dta.Path.html" />
    <link rel="prev" title="dta.MultiArray" href="dta.MultiArray.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dta.Path.html" title="dta.Path"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dta.MultiArray.html" title="dta.MultiArray"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">DTA Anyway v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dta-network">
<h1>dta.Network<a class="headerlink" href="#dta-network" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="dta.Network">
<em class="property">class </em><tt class="descclassname">dta.</tt><tt class="descname">Network</tt><big>(</big><em>scenario</em><big>)</big><a class="headerlink" href="#dta.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class that represents a DTA Network.  Networks exist on a continuum between
macro- and micro-simulation, and this network is meant to represent something
&#8220;typical&#8221; for a mesosimulation.  Something to be aware of in case it becomes too complicated.</p>
<p>Subclasses will be used to represent networks for different frameworks (Dynameq, Cube, etc)
so this class should have no code to deal with any particular file formats.</p>
<dl class="method">
<dt id="dta.Network.__init__">
<tt class="descname">__init__</tt><big>(</big><em>scenario</em><big>)</big><a class="headerlink" href="#dta.Network.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.  Initializes to an empty network, stores reference to given
scenario (a <a class="reference internal" href="dta.Scenario.html#dta.Scenario" title="dta.Scenario"><tt class="xref py py-class docutils literal"><span class="pre">Scenario</span></tt></a> instance).</p>
</dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#dta.Network.__init__" title="dta.Network.__init__"><tt class="xref py py-obj docutils literal"><span class="pre">__init__</span></tt></a></td>
<td>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.addAllMovements" title="dta.Network.addAllMovements"><tt class="xref py py-obj docutils literal"><span class="pre">Network.addAllMovements</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.addLink" title="dta.Network.addLink"><tt class="xref py py-obj docutils literal"><span class="pre">Network.addLink</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.addMovement" title="dta.Network.addMovement"><tt class="xref py py-obj docutils literal"><span class="pre">Network.addMovement</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.addNode" title="dta.Network.addNode"><tt class="xref py py-obj docutils literal"><span class="pre">Network.addNode</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.addPlanCollectionInfo" title="dta.Network.addPlanCollectionInfo"><tt class="xref py py-obj docutils literal"><span class="pre">Network.addPlanCollectionInfo</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.areIDsUnique" title="dta.Network.areIDsUnique"><tt class="xref py py-obj docutils literal"><span class="pre">Network.areIDsUnique</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.deepcopy" title="dta.Network.deepcopy"><tt class="xref py py-obj docutils literal"><span class="pre">Network.deepcopy</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.findLinksForRoadLabels" title="dta.Network.findLinksForRoadLabels"><tt class="xref py py-obj docutils literal"><span class="pre">Network.findLinksForRoadLabels</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.findMovementForRoadLabels" title="dta.Network.findMovementForRoadLabels"><tt class="xref py py-obj docutils literal"><span class="pre">Network.findMovementForRoadLabels</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getLinkForId" title="dta.Network.getLinkForId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getLinkForId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getLinkForNodeIdPair" title="dta.Network.getLinkForNodeIdPair"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getLinkForNodeIdPair</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getLinkType" title="dta.Network.getLinkType"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getLinkType</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getMaxLinkId" title="dta.Network.getMaxLinkId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getMaxLinkId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getMaxNodeId" title="dta.Network.getMaxNodeId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getMaxNodeId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNodeForId" title="dta.Network.getNodeForId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNodeForId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNodeType" title="dta.Network.getNodeType"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNodeType</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumCentroids" title="dta.Network.getNumCentroids"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumCentroids</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumConnectors" title="dta.Network.getNumConnectors"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumConnectors</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumLinks" title="dta.Network.getNumLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumNodes" title="dta.Network.getNumNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumOverlappingConnectors" title="dta.Network.getNumOverlappingConnectors"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumOverlappingConnectors</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumRoadLinks" title="dta.Network.getNumRoadLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumRoadLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumRoadNodes" title="dta.Network.getNumRoadNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumRoadNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumTimePlans" title="dta.Network.getNumTimePlans"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumTimePlans</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumVirtualLinks" title="dta.Network.getNumVirtualLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumVirtualLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getNumVirtualNodes" title="dta.Network.getNumVirtualNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getNumVirtualNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getPlanCollectionInfo" title="dta.Network.getPlanCollectionInfo"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getPlanCollectionInfo</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.getScenario" title="dta.Network.getScenario"><tt class="xref py py-obj docutils literal"><span class="pre">Network.getScenario</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.handleOverlappingLinks" title="dta.Network.handleOverlappingLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.handleOverlappingLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.handleShortLinks" title="dta.Network.handleShortLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.handleShortLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.hasCentroidForId" title="dta.Network.hasCentroidForId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.hasCentroidForId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.hasLinkForId" title="dta.Network.hasLinkForId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.hasLinkForId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.hasLinkForNodeIdPair" title="dta.Network.hasLinkForNodeIdPair"><tt class="xref py py-obj docutils literal"><span class="pre">Network.hasLinkForNodeIdPair</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.hasNodeForId" title="dta.Network.hasNodeForId"><tt class="xref py py-obj docutils literal"><span class="pre">Network.hasNodeForId</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.hasPlanCollectionInfo" title="dta.Network.hasPlanCollectionInfo"><tt class="xref py py-obj docutils literal"><span class="pre">Network.hasPlanCollectionInfo</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.insertVirtualNodeBetweenCentroidsAndRoadNodes" title="dta.Network.insertVirtualNodeBetweenCentroidsAndRoadNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.insertVirtualNodeBetweenCentroidsAndRoadNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterCentroids" title="dta.Network.iterCentroids"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterCentroids</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterConnectors" title="dta.Network.iterConnectors"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterConnectors</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterLinks" title="dta.Network.iterLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterNodes" title="dta.Network.iterNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterPlanCollectionInfo" title="dta.Network.iterPlanCollectionInfo"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterPlanCollectionInfo</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterRoadLinks" title="dta.Network.iterRoadLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterRoadLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterRoadNodes" title="dta.Network.iterRoadNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterRoadNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterVirtualLinks" title="dta.Network.iterVirtualLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterVirtualLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.iterVirtualNodes" title="dta.Network.iterVirtualNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.iterVirtualNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.mergeLinks" title="dta.Network.mergeLinks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.mergeLinks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.mergeSecondaryNetwork" title="dta.Network.mergeSecondaryNetwork"><tt class="xref py py-obj docutils literal"><span class="pre">Network.mergeSecondaryNetwork</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.mergeSecondaryNetworkBasedOnLinkIds" title="dta.Network.mergeSecondaryNetworkBasedOnLinkIds"><tt class="xref py py-obj docutils literal"><span class="pre">Network.mergeSecondaryNetworkBasedOnLinkIds</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.mergeSecondaryNetworkBasedOnLinkIds2" title="dta.Network.mergeSecondaryNetworkBasedOnLinkIds2"><tt class="xref py py-obj docutils literal"><span class="pre">Network.mergeSecondaryNetworkBasedOnLinkIds2</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.moveCentroidConnectorFromIntersectionToMidblock" title="dta.Network.moveCentroidConnectorFromIntersectionToMidblock"><tt class="xref py py-obj docutils literal"><span class="pre">Network.moveCentroidConnectorFromIntersectionToMidblock</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.moveCentroidConnectorsFromIntersectionsToMidblocks" title="dta.Network.moveCentroidConnectorsFromIntersectionsToMidblocks"><tt class="xref py py-obj docutils literal"><span class="pre">Network.moveCentroidConnectorsFromIntersectionsToMidblocks</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.moveVirtualNodesToAvoidShortConnectors" title="dta.Network.moveVirtualNodesToAvoidShortConnectors"><tt class="xref py py-obj docutils literal"><span class="pre">Network.moveVirtualNodesToAvoidShortConnectors</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.readLinkShape" title="dta.Network.readLinkShape"><tt class="xref py py-obj docutils literal"><span class="pre">Network.readLinkShape</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.removeLink" title="dta.Network.removeLink"><tt class="xref py py-obj docutils literal"><span class="pre">Network.removeLink</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.removeNode" title="dta.Network.removeNode"><tt class="xref py py-obj docutils literal"><span class="pre">Network.removeNode</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.removeShapePoints" title="dta.Network.removeShapePoints"><tt class="xref py py-obj docutils literal"><span class="pre">Network.removeShapePoints</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.removeUnconnectedNodes" title="dta.Network.removeUnconnectedNodes"><tt class="xref py py-obj docutils literal"><span class="pre">Network.removeUnconnectedNodes</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.renameLink" title="dta.Network.renameLink"><tt class="xref py py-obj docutils literal"><span class="pre">Network.renameLink</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.renameNode" title="dta.Network.renameNode"><tt class="xref py py-obj docutils literal"><span class="pre">Network.renameNode</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.setMovementTurnTypeOverrides" title="dta.Network.setMovementTurnTypeOverrides"><tt class="xref py py-obj docutils literal"><span class="pre">Network.setMovementTurnTypeOverrides</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.splitLink" title="dta.Network.splitLink"><tt class="xref py py-obj docutils literal"><span class="pre">Network.splitLink</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.writeLinksToShp" title="dta.Network.writeLinksToShp"><tt class="xref py py-obj docutils literal"><span class="pre">Network.writeLinksToShp</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.writeMovementsToShp" title="dta.Network.writeMovementsToShp"><tt class="xref py py-obj docutils literal"><span class="pre">Network.writeMovementsToShp</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#dta.Network.writeNodesToShp" title="dta.Network.writeNodesToShp"><tt class="xref py py-obj docutils literal"><span class="pre">Network.writeNodesToShp</span></tt></a></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dta.Network.addAllMovements">
<tt class="descname">addAllMovements</tt><big>(</big><em>vehicleClassGroup</em>, <em>includeUTurns=False</em><big>)</big><a class="headerlink" href="#dta.Network.addAllMovements" title="Permalink to this definition">¶</a></dt>
<dd><p>For each <a class="reference internal" href="dta.RoadNode.html#dta.RoadNode" title="dta.RoadNode"><tt class="xref py py-class docutils literal"><span class="pre">RoadNode</span></tt></a> and each <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a>, 
makes a movement for the given <em>vehicleClassGroup</em> (a <a class="reference internal" href="dta.VehicleClassGroup.html#dta.VehicleClassGroup" title="dta.VehicleClassGroup"><tt class="xref py py-class docutils literal"><span class="pre">VehicleClassGroup</span></tt></a> instance)
from each incoming link to each outgoing link 
(not including <a class="reference internal" href="dta.VirtualLink.html#dta.VirtualLink" title="dta.VirtualLink"><tt class="xref py py-class docutils literal"><span class="pre">VirtualLink</span></tt></a> instances).</p>
<p>If <em>includeUTurns</em>, includes U-Turn movements for each link as well, otherwise omits these.</p>
<p>If either the incoming link or the outgoing link returns false for <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.allowsAll" title="dta.RoadLink.allowsAll"><tt class="xref py py-meth docutils literal"><span class="pre">RoadLink.allowsAll()</span></tt></a>,
then uses the lane permission from that link instead.</p>
<div class="admonition-todo admonition " id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">This last bit is somewhat arbitrary, could be refined further.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.addLink">
<tt class="descname">addLink</tt><big>(</big><em>newLink</em><big>)</big><a class="headerlink" href="#dta.Network.addLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies that:</p>
<blockquote>
<div><ul class="simple">
<li>the <em>newLink</em> is a Link</li>
<li>that the id is not already used</li>
<li>the nodepair is not already used</li>
</ul>
</div></blockquote>
<p>Stores it.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.addMovement">
<tt class="descname">addMovement</tt><big>(</big><em>newMovement</em><big>)</big><a class="headerlink" href="#dta.Network.addMovement" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the movement by adding it to the movement&#8217;s incomingLink</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.addNode">
<tt class="descname">addNode</tt><big>(</big><em>newNode</em><big>)</big><a class="headerlink" href="#dta.Network.addNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies that <em>newNode</em> is a <a class="reference internal" href="dta.RoadNode.html#dta.RoadNode" title="dta.RoadNode"><tt class="xref py py-class docutils literal"><span class="pre">RoadNode</span></tt></a>, <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a> or <a class="reference internal" href="dta.Centroid.html#dta.Centroid" title="dta.Centroid"><tt class="xref py py-class docutils literal"><span class="pre">Centroid</span></tt></a>
and that the id is not already used; stores it.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.addPlanCollectionInfo">
<tt class="descname">addPlanCollectionInfo</tt><big>(</big><em>startTime</em>, <em>endTime</em>, <em>name</em>, <em>description</em><big>)</big><a class="headerlink" href="#dta.Network.addPlanCollectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>startTime <tt class="xref py py-class docutils literal"><span class="pre">Utils.Time</span></tt> instance 
endTime <tt class="xref py py-class docutils literal"><span class="pre">Utils.Time</span></tt> instance</p>
<p>name: a string that identifies the plan collection
description: a string that gives more infromation about the plan collection</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.areIDsUnique">
<tt class="descname">areIDsUnique</tt><big>(</big><em>net2</em><big>)</big><a class="headerlink" href="#dta.Network.areIDsUnique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the node and link Ids are unique</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.deepcopy">
<tt class="descname">deepcopy</tt><big>(</big><em>originNetwork</em><big>)</big><a class="headerlink" href="#dta.Network.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the contents of the originNetwork by creating copies of all its 
constituent elements into self (Nodes and Links and Movements, 
not the scenario). If the originNetwork contains an element 
with an already existing id this method will throw an exception.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.findLinksForRoadLabels">
<tt class="descname">findLinksForRoadLabels</tt><big>(</big><em>on_street_label</em>, <em>on_direction</em>, <em>from_street_label</em>, <em>to_street_label</em>, <em>remove_label_spaces=False</em><big>)</big><a class="headerlink" href="#dta.Network.findLinksForRoadLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to find the link(s) with the given <em>on_street_label</em> and <em>on_direction</em>
from the street matching <em>from_street_label</em> to the street matching <em>to_street_label</em>.</p>
<p><em>on_street_label</em>, <em>from_street_label</em> and <em>to_street_label</em> are checked against 
<a class="reference internal" href="dta.RoadLink.html#dta.RoadLink" title="dta.RoadLink"><tt class="xref py py-class docutils literal"><span class="pre">RoadLink</span></tt></a> labels and should be upper-case.  If <em>remove_label_spaces</em> is True, then
the labels will have their spaces stripped before comparison.</p>
<p><em>on_direction</em> is one of <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_EB" title="dta.RoadLink.DIR_EB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_EB</span></tt></a>, <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_NB" title="dta.RoadLink.DIR_NB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_NB</span></tt></a>,
<a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_WB" title="dta.RoadLink.DIR_WB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_WB</span></tt></a> or <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_SB" title="dta.RoadLink.DIR_SB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_SB</span></tt></a>.</p>
<p>Raises a <a class="reference internal" href="dta.DtaError.html#dta.DtaError" title="dta.DtaError"><tt class="xref py py-class docutils literal"><span class="pre">DtaError</span></tt></a> on failure, returns a list of <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink" title="dta.RoadLink"><tt class="xref py py-class docutils literal"><span class="pre">RoadLink</span></tt></a> instances on success.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.findMovementForRoadLabels">
<tt class="descname">findMovementForRoadLabels</tt><big>(</big><em>incoming_street_label</em>, <em>incoming_direction</em>, <em>outgoing_street_label</em>, <em>outgoing_direction</em>, <em>intersection_street_label=None</em>, <em>roadnode_id=None</em>, <em>remove_label_spaces=False</em>, <em>use_dir_for_movement=True</em>, <em>dir_need_not_be_primary=False</em><big>)</big><a class="headerlink" href="#dta.Network.findMovementForRoadLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to find the movement from the given <em>incoming_street_label</em> and <em>incoming_direction</em>
to the given <em>outgoing_street_label</em> and <em>outgoing_direction</em>.  If this is a through movement or a U-Turn
(e.g. <em>incoming_street_label</em> == <em>outgoing_street_label</em>), then <em>intersection_street_label</em> is also required
to identify the intersection.</p>
<p><em>incoming_street_label</em>, <em>outgoing_street_label</em> and <em>intersection_street_label</em> are checked against 
<a class="reference internal" href="dta.RoadLink.html#dta.RoadLink" title="dta.RoadLink"><tt class="xref py py-class docutils literal"><span class="pre">RoadLink</span></tt></a> labels and should be upper-case.  If <em>remove_label_spaces</em> is True, then
the labels will have their spaces stripped before comparison.</p>
<p><em>incoming_direction</em> and <em>outgoing_direction</em> are one of <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_EB" title="dta.RoadLink.DIR_EB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_EB</span></tt></a>, <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_NB" title="dta.RoadLink.DIR_NB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_NB</span></tt></a>,
<a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_WB" title="dta.RoadLink.DIR_WB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_WB</span></tt></a> or <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_SB" title="dta.RoadLink.DIR_SB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_SB</span></tt></a>.</p>
<p>Pass optional <em>roadnode_id</em> to speed things up but if the movement is not found for that <a class="reference internal" href="dta.RoadNode.html#dta.RoadNode" title="dta.RoadNode"><tt class="xref py py-class docutils literal"><span class="pre">RoadNode</span></tt></a>,
this method will fall back and try to find the movement based on the labels.</p>
<p>Pass <em>use_dir_for_movement</em> as True if the <em>incoming_street_label</em> and <em>outgoing_street_label</em> are useful
for identifying the intersection but not necessary for the movement (e.g. only the direction needs to match)</p>
<p>Pass <em>dir_need_not_be_primary</em> as True if the direction matching should be loose; e.g. 
if <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_EB" title="dta.RoadLink.DIR_EB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_EB</span></tt></a> means the link must be going eastbound <em>somewhat</em> even if it&#8217;s really heading
south east and so <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.getDirection" title="dta.RoadLink.getDirection"><tt class="xref py py-meth docutils literal"><span class="pre">RoadLink.getDirection()</span></tt></a> returns :py:attr:RoadLink.DIR_SB`.</p>
<p>Raises a <a class="reference internal" href="dta.DtaError.html#dta.DtaError" title="dta.DtaError"><tt class="xref py py-class docutils literal"><span class="pre">DtaError</span></tt></a> on failure, returns a <a class="reference internal" href="dta.Movement.html#dta.Movement" title="dta.Movement"><tt class="xref py py-class docutils literal"><span class="pre">Movement</span></tt></a> instance on success.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getLinkForId">
<tt class="descname">getLinkForId</tt><big>(</big><em>linkId</em><big>)</big><a class="headerlink" href="#dta.Network.getLinkForId" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for link given the <em>linkId</em>.
Raises <a class="reference internal" href="dta.DtaError.html#dta.DtaError" title="dta.DtaError"><tt class="xref py py-class docutils literal"><span class="pre">DtaError</span></tt></a> if not found.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getLinkForNodeIdPair">
<tt class="descname">getLinkForNodeIdPair</tt><big>(</big><em>nodeAId</em>, <em>nodeBId</em><big>)</big><a class="headerlink" href="#dta.Network.getLinkForNodeIdPair" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for the link given the link nodes.
Raises <a class="reference internal" href="dta.DtaError.html#dta.DtaError" title="dta.DtaError"><tt class="xref py py-class docutils literal"><span class="pre">DtaError</span></tt></a> if not found.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getLinkType">
<tt class="descname">getLinkType</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getLinkType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unique integer representing the link type</p>
<div class="admonition-todo admonition " id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">What is this for?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getMaxLinkId">
<tt class="descname">getMaxLinkId</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getMaxLinkId" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the max link Id in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getMaxNodeId">
<tt class="descname">getMaxNodeId</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getMaxNodeId" title="Permalink to this definition">¶</a></dt>
<dd><p>REturn the max noe id in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNodeForId">
<tt class="descname">getNodeForId</tt><big>(</big><em>nodeId</em><big>)</big><a class="headerlink" href="#dta.Network.getNodeForId" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for node given the <em>nodeId</em>.
Raises <a class="reference internal" href="dta.DtaError.html#dta.DtaError" title="dta.DtaError"><tt class="xref py py-class docutils literal"><span class="pre">DtaError</span></tt></a> if not found.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNodeType">
<tt class="descname">getNodeType</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNodeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unique integer representing the node type.</p>
<div class="admonition-todo admonition " id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">What is this for?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumCentroids">
<tt class="descname">getNumCentroids</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumCentroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of centroids in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumConnectors">
<tt class="descname">getNumConnectors</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumConnectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of connectors in the Network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumLinks">
<tt class="descname">getNumLinks</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of links in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumNodes">
<tt class="descname">getNumNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumOverlappingConnectors">
<tt class="descname">getNumOverlappingConnectors</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumOverlappingConnectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of connectors that overlap with a RoadLink or 
another connector</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumRoadLinks">
<tt class="descname">getNumRoadLinks</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumRoadLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of RoadLinks in the Network(excluding connectors)</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumRoadNodes">
<tt class="descname">getNumRoadNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumRoadNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of roadnodes in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumTimePlans">
<tt class="descname">getNumTimePlans</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumTimePlans" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes with a time plan</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumVirtualLinks">
<tt class="descname">getNumVirtualLinks</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumVirtualLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of connectors in the Network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getNumVirtualNodes">
<tt class="descname">getNumVirtualNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getNumVirtualNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of virtual nodes in the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getPlanCollectionInfo">
<tt class="descname">getPlanCollectionInfo</tt><big>(</big><em>startTime</em>, <em>endTime</em><big>)</big><a class="headerlink" href="#dta.Network.getPlanCollectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the plan collection info for the given input times
startTime <tt class="xref py py-class docutils literal"><span class="pre">Utils.Time</span></tt> instance 
endTime <tt class="xref py py-class docutils literal"><span class="pre">Utils.Time</span></tt> instance</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.getScenario">
<tt class="descname">getScenario</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.getScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the scenario object associated with this network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.handleOverlappingLinks">
<tt class="descname">handleOverlappingLinks</tt><big>(</big><em>warn</em>, <em>moveVirtualNodeDist=None</em><big>)</big><a class="headerlink" href="#dta.Network.handleOverlappingLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>For each node, checks if any incoming links overlap, and if any outgoing links overlap.</p>
<p>If <em>moveVirtualNodeDist</em> is passed, if the overlapping links includes a c:py:class:<cite>Connector</cite>,
the <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a> instance will be moved +- <em>moveVirtualNodeDist</em> in each direction
to see if that resolves the overlap.  If not, the node retains its original location.</p>
<p><em>moveVirtualNodeDist</em> is in <a class="reference internal" href="dta.Node.html#dta.Node.COORDINATE_UNITS" title="dta.Node.COORDINATE_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">Node.COORDINATE_UNITS</span></tt></a></p>
<dl class="docutils">
<dt>(order attempted: (0,+dist), (+dist,0), (0,-dist), (-dist,0), </dt>
<dd>(+dist,-dist), (+dist,+dist), (-dist,+dist), (-dist,-dist))</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dta.Network.handleShortLinks">
<tt class="descname">handleShortLinks</tt><big>(</big><em>minLength</em>, <em>warn</em>, <em>setLength</em><big>)</big><a class="headerlink" href="#dta.Network.handleShortLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Goes through the <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink" title="dta.RoadLink"><tt class="xref py py-class docutils literal"><span class="pre">RoadLink</span></tt></a> instances (including <tt class="xref py py-class docutils literal"><span class="pre">Connectors</span></tt>)
and for those with lengths less than <em>minLength</em>, do the following:</p>
<ul class="simple">
<li>if <em>warn</em> then issue a warning</li>
<li>if <em>setLength</em> then adjust the length attribute to the minimum</li>
</ul>
<p>Note that <em>minLength</em> and <em>setLength</em> are both in the units specified by <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.LENGTH_UNITS" title="dta.RoadLink.LENGTH_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.LENGTH_UNITS</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.hasCentroidForId">
<tt class="descname">hasCentroidForId</tt><big>(</big><em>nodeId</em><big>)</big><a class="headerlink" href="#dta.Network.hasCentroidForId" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if there is a centroid with the given id</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.hasLinkForId">
<tt class="descname">hasLinkForId</tt><big>(</big><em>linkId</em><big>)</big><a class="headerlink" href="#dta.Network.hasLinkForId" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if a link with the given id exists</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.hasLinkForNodeIdPair">
<tt class="descname">hasLinkForNodeIdPair</tt><big>(</big><em>startNodeId</em>, <em>endNodeId</em><big>)</big><a class="headerlink" href="#dta.Network.hasLinkForNodeIdPair" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the network has a link with the given node ids</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.hasNodeForId">
<tt class="descname">hasNodeForId</tt><big>(</big><em>nodeId</em><big>)</big><a class="headerlink" href="#dta.Network.hasNodeForId" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if there is a node with the given id</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.hasPlanCollectionInfo">
<tt class="descname">hasPlanCollectionInfo</tt><big>(</big><em>startTime</em>, <em>endTime</em><big>)</big><a class="headerlink" href="#dta.Network.hasPlanCollectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the network has a time plan connection for the given
start and end times
startTime <tt class="xref py py-class docutils literal"><span class="pre">Utils.Time</span></tt> instance 
endTime <tt class="xref py py-class docutils literal"><span class="pre">Utils.Time</span></tt> instance</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.insertVirtualNodeBetweenCentroidsAndRoadNodes">
<tt class="descname">insertVirtualNodeBetweenCentroidsAndRoadNodes</tt><big>(</big><em>startVirtualNodeId=None</em>, <em>startVirtualLinkId=None</em>, <em>distanceFromCentroid=0</em><big>)</big><a class="headerlink" href="#dta.Network.insertVirtualNodeBetweenCentroidsAndRoadNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>In some situations (for example, for a Dynameq netork), there need to be intermediate nodes between
<a class="reference internal" href="dta.Centroid.html#dta.Centroid" title="dta.Centroid"><tt class="xref py py-class docutils literal"><span class="pre">Centroid</span></tt></a> nodes and <a class="reference internal" href="dta.RoadNode.html#dta.RoadNode" title="dta.RoadNode"><tt class="xref py py-class docutils literal"><span class="pre">RoadNode</span></tt></a> objects.</p>
<img alt="../_images/addVirtualNode_before_after.png" src="../_images/addVirtualNode_before_after.png" style="height: 300px;" />
<p>If defined, the virtual nodes that will be added will begin from <em>startVirtualNodeId</em> and the
virtual links from <em>startVirtualLinkId</em>.  The new virtual node will be placed along the connector
link a distance away from the centroid specified by <em>distanceFromCentroid</em> (in <a class="reference internal" href="dta.Node.html#dta.Node.COORDINATE_UNITS" title="dta.Node.COORDINATE_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">Node.COORDINATE_UNITS</span></tt></a>),
so it will be in the same location if that argument is specified as zero.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterCentroids">
<tt class="descname">iterCentroids</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterCentroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the <a class="reference internal" href="dta.Centroid.html#dta.Centroid" title="dta.Centroid"><tt class="xref py py-class docutils literal"><span class="pre">Centroid</span></tt></a> instances in the network.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterConnectors">
<tt class="descname">iterConnectors</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterConnectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the <a class="reference internal" href="dta.Connector.html#dta.Connector" title="dta.Connector"><tt class="xref py py-class docutils literal"><span class="pre">Connector</span></tt></a> instances in the network.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterLinks">
<tt class="descname">iterLinks</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the link collection</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterNodes">
<tt class="descname">iterNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the node collection</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterPlanCollectionInfo">
<tt class="descname">iterPlanCollectionInfo</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterPlanCollectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the planInfo objects</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterRoadLinks">
<tt class="descname">iterRoadLinks</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterRoadLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator for to the <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink" title="dta.RoadLink"><tt class="xref py py-class docutils literal"><span class="pre">RoadLink</span></tt></a> instances in the network that are
not instances of <a class="reference internal" href="dta.Connector.html#dta.Connector" title="dta.Connector"><tt class="xref py py-class docutils literal"><span class="pre">Connector</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterRoadNodes">
<tt class="descname">iterRoadNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterRoadNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the <a class="reference internal" href="dta.RoadNode.html#dta.RoadNode" title="dta.RoadNode"><tt class="xref py py-class docutils literal"><span class="pre">RoadNode</span></tt></a> instances in the network.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterVirtualLinks">
<tt class="descname">iterVirtualLinks</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterVirtualLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the <a class="reference internal" href="dta.VirtualLink.html#dta.VirtualLink" title="dta.VirtualLink"><tt class="xref py py-class docutils literal"><span class="pre">VirtualLink</span></tt></a> instances in the network.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.iterVirtualNodes">
<tt class="descname">iterVirtualNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.iterVirtualNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator to the <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a> instances in the network.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.mergeLinks">
<tt class="descname">mergeLinks</tt><big>(</big><em>link1</em>, <em>link2</em><big>)</big><a class="headerlink" href="#dta.Network.mergeLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the two input sequential links. If any of the characteristics of the 
two links are different (except their length) the method will throw an 
error</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.mergeSecondaryNetwork">
<tt class="descname">mergeSecondaryNetwork</tt><big>(</big><em>secondaryNetwork</em><big>)</big><a class="headerlink" href="#dta.Network.mergeSecondaryNetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will create a polygon around the current 
(primary network). Every node or link of the secondary network 
that is not in the polygon will be copied.</p>
<div class="admonition-todo admonition " id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">Code review and more detailed documentation.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.mergeSecondaryNetworkBasedOnLinkIds">
<tt class="descname">mergeSecondaryNetworkBasedOnLinkIds</tt><big>(</big><em>secondaryNetwork</em><big>)</big><a class="headerlink" href="#dta.Network.mergeSecondaryNetworkBasedOnLinkIds" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will add all the elements of the secondary
network to the current one. The method will throw an
exception if there is an element of the current and
secondary network have a common id</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.mergeSecondaryNetworkBasedOnLinkIds2">
<tt class="descname">mergeSecondaryNetworkBasedOnLinkIds2</tt><big>(</big><em>secondaryNetwork</em><big>)</big><a class="headerlink" href="#dta.Network.mergeSecondaryNetworkBasedOnLinkIds2" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will create copies of all the elements of the 
secondary network that do not exist in the current network 
and add them to the current network. The method will merge the 
networks using node and link ids. Elements of the secondary 
network having an id that exists in this network will not be 
coppied.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.moveCentroidConnectorFromIntersectionToMidblock">
<tt class="descname">moveCentroidConnectorFromIntersectionToMidblock</tt><big>(</big><em>roadNode</em>, <em>connector</em>, <em>splitReverseLink=False</em>, <em>moveVirtualNodeDist=None</em><big>)</big><a class="headerlink" href="#dta.Network.moveCentroidConnectorFromIntersectionToMidblock" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the input connector for an intersection and attach it to a midblock 
location. If a midblock location does does not exist a RoadLink close
to the connector is split in half and the connector is attached to the new 
midblock location.</p>
<p>If <em>moveVirtualNodeDist</em> is not None, if no candidate links are found, the method will 
try moving the <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a> instance around to find a candidate link. 
<em>moveVirtualNodeDist</em> is in <a class="reference internal" href="dta.Node.html#dta.Node.COORDINATE_UNITS" title="dta.Node.COORDINATE_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">Node.COORDINATE_UNITS</span></tt></a></p>
<div class="admonition-todo admonition " id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">I would like more detail about this.  How are movements handled for VehicleClassGroups?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.moveCentroidConnectorsFromIntersectionsToMidblocks">
<tt class="descname">moveCentroidConnectorsFromIntersectionsToMidblocks</tt><big>(</big><em>splitReverseLinks=False</em>, <em>moveVirtualNodeDist=None</em>, <em>externalNodeIds=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#dta.Network.moveCentroidConnectorsFromIntersectionsToMidblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove centroid connectors from intersections and attach them to midblock locations.
If there is not a node defining a midblock location the algorithm will split the 
relevant links (in both directions) and attach the connector to the newly 
created node.</p>
<p>If <em>moveVirtualNodeDist</em> is not None, if no candidate links are found, the method will 
try moving the <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a> instance around to find a candidate link. 
<em>moveVirtualNodeDist</em> is in <a class="reference internal" href="dta.Node.html#dta.Node.COORDINATE_UNITS" title="dta.Node.COORDINATE_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">Node.COORDINATE_UNITS</span></tt></a></p>
<p>Before:</p>
<img alt="../_images/removeCentroidConnectors1.png" src="../_images/removeCentroidConnectors1.png" style="height: 300px;" />
<p>After:</p>
<img alt="../_images/removeCentroidConnectors2.png" src="../_images/removeCentroidConnectors2.png" style="height: 300px;" />
</dd></dl>

<dl class="method">
<dt id="dta.Network.moveVirtualNodesToAvoidShortConnectors">
<tt class="descname">moveVirtualNodesToAvoidShortConnectors</tt><big>(</big><em>connectorMinLength</em>, <em>maxDistToMove</em><big>)</big><a class="headerlink" href="#dta.Network.moveVirtualNodesToAvoidShortConnectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Connectors are sometimes too short. This method tries to move 
the virtual node attached to the connector in the vicinity 
of the current virtual node so that the connector length is 
greater than <em>connectorMinLength</em>, which should be in the units given by <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.LENGTH_UNITS" title="dta.RoadLink.LENGTH_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.LENGTH_UNITS</span></tt></a>.</p>
<p>The <a class="reference internal" href="dta.VirtualNode.html#dta.VirtualNode" title="dta.VirtualNode"><tt class="xref py py-class docutils literal"><span class="pre">VirtualNode</span></tt></a> will be moved randomly within the bounding box defined by its
current location +/- <em>maxDistToMove</em>, where <em>maxDistToMove</em> is in the units given by 
<a class="reference internal" href="dta.Node.html#dta.Node.COORDINATE_UNITS" title="dta.Node.COORDINATE_UNITS"><tt class="xref py py-attr docutils literal"><span class="pre">Node.COORDINATE_UNITS</span></tt></a>.</p>
<p>This will be repeated until the connector is long enough (up to 4 times).</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.readLinkShape">
<tt class="descname">readLinkShape</tt><big>(</big><em>linkShapefile</em>, <em>startNodeIdField</em>, <em>endNodeIdField</em>, <em>skipEvalStr=None</em><big>)</big><a class="headerlink" href="#dta.Network.readLinkShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the given <em>linkShapefile</em> to add shape points to the network, in order to more accurately
represent the geometry of the roads.  For curvey or winding roads, this will help reduce errors in understanding
intersections because of the angles involved.</p>
<p><em>startNodeIdField</em> and <em>endNodeIdField</em> are the column headers (so they&#8217;re strings)
of the start node and end node IDs within the <em>linkShapefile</em>.</p>
<p>Optional argument <em>skipEvalStr</em> will be eval()ed by python, and if the expression returns True,
the row will be skipped.  For example, to skip a specific couple of entries, the caller could pass
<tt class="docutils literal"><span class="pre">&quot;OBJECTID</span> <span class="pre">in</span> <span class="pre">[5234,2798]&quot;</span></tt>.</p>
<p>If a link with the same (node1,node2) pair is specified more than once in the shapefile, only the first one
will be used.</p>
<p>Does this in two passes; in the first pass, the (a,b) from the shapefile is looked up in the network, and used
to add shape points.  In the second pass, the (b,a) from the shapefile is looked up in the network, and used
to add shape points <strong>if that link has not already been updated from the first pass</strong>.</p>
<div class="admonition-todo admonition " id="index-5">
<p class="first admonition-title">Todo</p>
<p class="last">Dynameq warns/throws away shape points when there is only one, which makes me think the start or end
node should be included too.  However, if we include either the first or the last shape point below,
everything goes crazy.  I&#8217;m not sure why?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.removeLink">
<tt class="descname">removeLink</tt><big>(</big><em>linkToRemove</em><big>)</big><a class="headerlink" href="#dta.Network.removeLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the input link from the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.removeNode">
<tt class="descname">removeNode</tt><big>(</big><em>nodeToRemove</em><big>)</big><a class="headerlink" href="#dta.Network.removeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the input node from the network</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.removeShapePoints">
<tt class="descname">removeShapePoints</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.removeShapePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove shape points from the network</p>
<div class="admonition-todo admonition " id="index-6">
<p class="first admonition-title">Todo</p>
<p class="last">These are not the same &#8220;shape points&#8221; as the <tt class="xref py py-class docutils literal"><span class="pre">RoadLink._shapePoints</span></tt>.  Define what these
are (call them something else if they&#8217;re not the same).  Also, why wouldn&#8217;t we convert them to
the other kind?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.removeUnconnectedNodes">
<tt class="descname">removeUnconnectedNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#dta.Network.removeUnconnectedNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any nodes that aren&#8217;t linked to anything (have no adjacent links).</p>
<p>This might be useful for networks with too many nodes for the DTA software license.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.renameLink">
<tt class="descname">renameLink</tt><big>(</big><em>oldLinkId</em>, <em>newLinkId</em><big>)</big><a class="headerlink" href="#dta.Network.renameLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the newLinkId to the link with oldLinkId</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.renameNode">
<tt class="descname">renameNode</tt><big>(</big><em>oldNodeId</em>, <em>newNodeId</em><big>)</big><a class="headerlink" href="#dta.Network.renameNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the node with oldNodeId the new id</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.setMovementTurnTypeOverrides">
<tt class="descname">setMovementTurnTypeOverrides</tt><big>(</big><em>overrides</em><big>)</big><a class="headerlink" href="#dta.Network.setMovementTurnTypeOverrides" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets movement turn type overrides.  <em>overrides</em> is specified as a list of overrides, where each override
is a tuple containing ( <em>from_dir</em>, <em>from_street</em>, <em>cross_street</em>, <em>to_dir</em>, <em>to_street</em>, <em>turn_type</em>, [<em>perm_type</em>] ).</p>
<p><em>from_dir</em> and <em>to_dir</em> should be one of <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_EB" title="dta.RoadLink.DIR_EB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_EB</span></tt></a>, <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_WB" title="dta.RoadLink.DIR_WB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_WB</span></tt></a>, <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_NB" title="dta.RoadLink.DIR_NB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_NB</span></tt></a>, 
and <a class="reference internal" href="dta.RoadLink.html#dta.RoadLink.DIR_SB" title="dta.RoadLink.DIR_SB"><tt class="xref py py-attr docutils literal"><span class="pre">RoadLink.DIR_SB</span></tt></a>.</p>
<p><em>from_street</em>, <em>cross_street</em> and <em>to_street</em> should be labels (corresponding to <a class="reference internal" href="dta.Link.html#dta.Link.getLabel" title="dta.Link.getLabel"><tt class="xref py py-meth docutils literal"><span class="pre">Link.getLabel()</span></tt></a>)</p>
<p><em>turn_type</em> should be one of <a class="reference internal" href="dta.Movement.html#dta.Movement.DIR_UTURN" title="dta.Movement.DIR_UTURN"><tt class="xref py py-attr docutils literal"><span class="pre">Movement.DIR_UTURN</span></tt></a>, <a class="reference internal" href="dta.Movement.html#dta.Movement.DIR_RT" title="dta.Movement.DIR_RT"><tt class="xref py py-attr docutils literal"><span class="pre">Movement.DIR_RT</span></tt></a>, <a class="reference internal" href="dta.Movement.html#dta.Movement.DIR_RT2" title="dta.Movement.DIR_RT2"><tt class="xref py py-attr docutils literal"><span class="pre">Movement.DIR_RT2</span></tt></a>,
<a class="reference internal" href="dta.Movement.html#dta.Movement.DIR_LT2" title="dta.Movement.DIR_LT2"><tt class="xref py py-attr docutils literal"><span class="pre">Movement.DIR_LT2</span></tt></a>, <a class="reference internal" href="dta.Movement.html#dta.Movement.DIR_LT" title="dta.Movement.DIR_LT"><tt class="xref py py-attr docutils literal"><span class="pre">Movement.DIR_LT</span></tt></a>, <a class="reference internal" href="dta.Movement.html#dta.Movement.DIR_TH" title="dta.Movement.DIR_TH"><tt class="xref py py-attr docutils literal"><span class="pre">Movement.DIR_TH</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.splitLink">
<tt class="descname">splitLink</tt><big>(</big><em>linkToSplit</em>, <em>splitReverseLink=False</em><big>)</big><a class="headerlink" href="#dta.Network.splitLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the input link in half. The two new links have the 
attributes of the input link. If there is a link in the 
opposing direction then split that too.</p>
<div class="admonition-todo admonition " id="index-7">
<p class="first admonition-title">Todo</p>
<p class="last">Document the how the movements are handled, especially regarding VehicleClassGroups.
Currently it looks like an ALL and a PROHIBITED are required?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="dta.Network.writeLinksToShp">
<tt class="descname">writeLinksToShp</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#dta.Network.writeLinksToShp" title="Permalink to this definition">¶</a></dt>
<dd><p>Export all the links to a shapefile with the given name (without the shp extension)</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.writeMovementsToShp">
<tt class="descname">writeMovementsToShp</tt><big>(</big><em>name</em>, <em>planInfo=None</em><big>)</big><a class="headerlink" href="#dta.Network.writeMovementsToShp" title="Permalink to this definition">¶</a></dt>
<dd><p>Export all the movements to a shapefile with the given name</p>
</dd></dl>

<dl class="method">
<dt id="dta.Network.writeNodesToShp">
<tt class="descname">writeNodesToShp</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#dta.Network.writeNodesToShp" title="Permalink to this definition">¶</a></dt>
<dd><p>Export all the nodes to a shapefile with the given name (without the shp extension)&#8221;</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="dta.MultiArray.html"
                        title="previous chapter">dta.MultiArray</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dta.Path.html"
                        title="next chapter">dta.Path</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/_generated/dta.Network.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dta.Path.html" title="dta.Path"
             >next</a> |</li>
        <li class="right" >
          <a href="dta.MultiArray.html" title="dta.MultiArray"
             >previous</a> |</li>
        <li><a href="../index.html">DTA Anyway v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, SFCTA Modeling Crew.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>